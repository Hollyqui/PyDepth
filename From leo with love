import numpy as np
if __name__ == '__main__':

    #LEFT IMAGE    
    count=0
    left_matrix = []
    for j in range(480):
        left_matrix.append([])
        for i in range(640):
            left_matrix[j].append(count)
            count+=1

    left_matrix = np.array(left_matrix) #WE HAVE RANDOM LEFT IMAGE

    square_size = 4
    left_square = left_matrix[i-square_size:i+square_size+1][j-square_size:j+square_size+1]

    #RIGHT IMAGE          
    count=0
    right_matrix = []
    for y in range(480):
        right_matrix.append([])
        for x in range(640):
            right_matrix.append(count)
            count+=1

    right_matrix = np.array(left_matrix) #WE HAVE RANDOM RIGHT IMAGE

    right_square = right_matrix[x-square_size:x+square_size+1][y-square_size:y+square_size+1]

    comparison_train_function(left_matrix, right_matrix, left_square, right_square, j, i, x, y)
    
    def comparison_train_function(left_matrix, right_matrix, left_square, right_square, j, i, x, y):

    #DEFINING VARIABLES NOT YET DEFINED
        sa_h=3 #just search area height
        sa_w=10 #just search area width
        sa_height=right_matrix[j-sa_h:j+sa_h+1] #search area window
        sa_width=right_matrix[i-sa_w:i+sa_w+1] #search area window
        #left_square = matrix[i-square_size:i+square_size+1, j-square_size:j+square_size+1]

    #LOOK FOR COMMON AREA    
        for y in left_matrix: #vertical
            for x in left_matrix: #up until here: for every pixel on the left image #horizontal
                #now: go through every element of the search area
                for j in sa_height:
                    for i in sa_width: #for every pixel of the search area that corresponds to every pixel in left image
                        #store pixel value( )square size) in matrix form, located at left and right image at (x, y) and (i, j) respectively
                        #calculate the area of overlap of 2 squares 

                        if (range((left_matrix[tuple(x)])) >= range((sa_width[tuple(i)])) and range((sa_height[tuple(j)])) >= range((left_matrix[tuple(y)]))):
                            area=((i+square_size)-(x-square_size))*((j-square_size)-(y+square_size))
                        elif (x <= i and j >= y):
                            area=((x+square_size)-(i-square_size))*((y+square_size)-(j-square_size))
                        elif (x >= i and j <= y):
                            area=((i+square_size)-(x-square_size))*((j+square_size)-(y-square_size))
                        elif (x <= i and j <= y):
                            area=((x+square_size)-(i-square_size))*((j+square_size)-(y-square_size))


                        print("The left image has pixel values ",Left_square, "for coordinates (", y, x, ") which correspond to coordinates (", j, i, ") (within the search area) on the right image; these have pixel values", Right_square, ". The amount of pixel overlap is ", area)
                        
                        

if __name__ == '__main__':

    #LEFT IMAGE    
    count=0
    left_matrix = []
    for j in range(480):
        left_matrix.append([])
        for i in range(640):
            left_matrix[j].append(count)
            count+=1

    left_matrix = np.array(left_matrix) #WE HAVE RANDOM LEFT IMAGE

    square_size = 4
    left_square = left_matrix[i-square_size:i+square_size+1][j-square_size:j+square_size+1]

    #RIGHT IMAGE          
    count=0
    right_matrix = []
    for y in range(480):
        right_matrix.append([])
        for x in range(640):
            right_matrix.append(count)
            count+=1

    right_matrix = np.array(left_matrix) #WE HAVE RANDOM RIGHT IMAGE

    right_square = right_matrix[x-square_size:x+square_size+1][y-square_size:y+square_size+1]

    comparison_train_function(left_matrix, right_matrix, left_square, right_square, j, i, x, y)
